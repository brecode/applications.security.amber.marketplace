// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package commercialmarketplace

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

type BatchUsageEvent struct {
	Request []*UsageEvent `json:"request,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchUsageEvent.
func (b BatchUsageEvent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "request", b.Request)
	return json.Marshal(objectMap)
}

type BatchUsageEventOkResponse struct {
	Count *int32 `json:"count,omitempty"`
	Result []*UsageBatchEventOkMessage `json:"result,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchUsageEventOkResponse.
func (b BatchUsageEventOkResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "count", b.Count)
	populate(objectMap, "result", b.Result)
	return json.Marshal(objectMap)
}

// MeteringOperationsPostBatchUsageEventOptions contains the optional parameters for the MeteringOperations.PostBatchUsageEvent method.
type MeteringOperationsPostBatchUsageEventOptions struct {
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

// MeteringOperationsPostUsageEventOptions contains the optional parameters for the MeteringOperations.PostUsageEvent method.
type MeteringOperationsPostUsageEventOptions struct {
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

type UsageBatchEventOkMessage struct {
	// Dimension identifier
	Dimension *string `json:"dimension,omitempty"`

	// Time in UTC when the usage event occurred
	EffectiveStartTime *time.Time `json:"effectiveStartTime,omitempty"`
	Error *UsageEventConflictResponse `json:"error,omitempty"`

	// Time this message was created in UTC
	MessageTime *time.Time `json:"messageTime,omitempty"`

	// Plan associated with the purchased offer
	PlanID *string `json:"planId,omitempty"`

	// Number of units consumed
	Quantity *float64 `json:"quantity,omitempty"`

	// Identifier of the resource against which usage is emitted
	ResourceID *string `json:"resourceId,omitempty"`

	// Identifier of the managed app resource against which usage is emitted
	ResourceURI *string `json:"resourceUri,omitempty"`

	// Status of the operation.
	Status *UsageEventStatusEnum `json:"status,omitempty"`

	// Unique identifier associated with the usage event
	UsageEventID *string `json:"usageEventId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UsageBatchEventOkMessage.
func (u UsageBatchEventOkMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dimension", u.Dimension)
	populate(objectMap, "effectiveStartTime", (*timeRFC3339)(u.EffectiveStartTime))
	populate(objectMap, "error", u.Error)
	populate(objectMap, "messageTime", (*timeRFC3339)(u.MessageTime))
	populate(objectMap, "planId", u.PlanID)
	populate(objectMap, "quantity", u.Quantity)
	populate(objectMap, "resourceId", u.ResourceID)
	populate(objectMap, "resourceUri", u.ResourceURI)
	populate(objectMap, "status", u.Status)
	populate(objectMap, "usageEventId", u.UsageEventID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UsageBatchEventOkMessage.
func (u *UsageBatchEventOkMessage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dimension":
				err = unpopulate(val, &u.Dimension)
				delete(rawMsg, key)
		case "effectiveStartTime":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				u.EffectiveStartTime = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "error":
				err = unpopulate(val, &u.Error)
				delete(rawMsg, key)
		case "messageTime":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				u.MessageTime = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "planId":
				err = unpopulate(val, &u.PlanID)
				delete(rawMsg, key)
		case "quantity":
				err = unpopulate(val, &u.Quantity)
				delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, &u.ResourceID)
				delete(rawMsg, key)
		case "resourceUri":
				err = unpopulate(val, &u.ResourceURI)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, &u.Status)
				delete(rawMsg, key)
		case "usageEventId":
				err = unpopulate(val, &u.UsageEventID)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type UsageEvent struct {
	// Dimension identifier
	Dimension *string `json:"dimension,omitempty"`

	// Time in UTC when the usage event occurred
	EffectiveStartTime *time.Time `json:"effectiveStartTime,omitempty"`

	// Plan associated with the purchased offer
	PlanID *string `json:"planId,omitempty"`

	// Number of units consumed
	Quantity *float64 `json:"quantity,omitempty"`

	// subscriptionId property value for SaaS offer subscriptions; resourceUsageId property on the managed application resource for managed application offers.
// For managed applications, only use one of
// resourceId or resourceUri.
	ResourceID *string `json:"resourceId,omitempty"`

	// Resource URI for the managed app. Used with managed applications. Only use resourceUri or resourceId, but never both.
	ResourceURI *string `json:"resourceUri,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UsageEvent.
func (u UsageEvent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dimension", u.Dimension)
	populate(objectMap, "effectiveStartTime", (*timeRFC3339)(u.EffectiveStartTime))
	populate(objectMap, "planId", u.PlanID)
	populate(objectMap, "quantity", u.Quantity)
	populate(objectMap, "resourceId", u.ResourceID)
	populate(objectMap, "resourceUri", u.ResourceURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UsageEvent.
func (u *UsageEvent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dimension":
				err = unpopulate(val, &u.Dimension)
				delete(rawMsg, key)
		case "effectiveStartTime":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				u.EffectiveStartTime = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "planId":
				err = unpopulate(val, &u.PlanID)
				delete(rawMsg, key)
		case "quantity":
				err = unpopulate(val, &u.Quantity)
				delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, &u.ResourceID)
				delete(rawMsg, key)
		case "resourceUri":
				err = unpopulate(val, &u.ResourceURI)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Implements the error and azcore.HTTPResponse interfaces.
type UsageEventBadRequestResponse struct {
	raw string
	Code *string `json:"code,omitempty"`
	Details []*UsageEventBadRequestResponseDetail `json:"details,omitempty"`
	Message *string `json:"message,omitempty"`
	Target *string `json:"target,omitempty"`
}

// Error implements the error interface for type UsageEventBadRequestResponse.
// The contents of the error text are not contractual and subject to change.
func (e UsageEventBadRequestResponse) Error() string {
	return e.raw
}

type UsageEventBadRequestResponseDetail struct {
	Code *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
	Target *string `json:"target,omitempty"`
}

// Implements the error and azcore.HTTPResponse interfaces.
type UsageEventConflictResponse struct {
	raw string
	AdditionalInfo *UsageEventConflictResponseAdditionalInfo `json:"additionalInfo,omitempty"`
	Code *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Error implements the error interface for type UsageEventConflictResponse.
// The contents of the error text are not contractual and subject to change.
func (e UsageEventConflictResponse) Error() string {
	return e.raw
}

type UsageEventConflictResponseAdditionalInfo struct {
	AcceptedMessage *UsageEventOkResponse `json:"acceptedMessage,omitempty"`
}

type UsageEventOkResponse struct {
	// Dimension identifier
	Dimension *string `json:"dimension,omitempty"`

	// Time in UTC when the usage event occurred
	EffectiveStartTime *time.Time `json:"effectiveStartTime,omitempty"`

	// Time this message was created in UTC
	MessageTime *time.Time `json:"messageTime,omitempty"`

	// Plan associated with the purchased offer
	PlanID *string `json:"planId,omitempty"`

	// Number of units consumed
	Quantity *float64 `json:"quantity,omitempty"`

	// Identifier of the resource against which usage is emitted
	ResourceID *string `json:"resourceId,omitempty"`

	// Identifier of the managed app resource against which usage is emitted
	ResourceURI *string `json:"resourceUri,omitempty"`

	// Status of the operation.
	Status *UsageEventStatusEnum `json:"status,omitempty"`

	// Unique identifier associated with the usage event
	UsageEventID *string `json:"usageEventId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UsageEventOkResponse.
func (u UsageEventOkResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dimension", u.Dimension)
	populate(objectMap, "effectiveStartTime", (*timeRFC3339)(u.EffectiveStartTime))
	populate(objectMap, "messageTime", (*timeRFC3339)(u.MessageTime))
	populate(objectMap, "planId", u.PlanID)
	populate(objectMap, "quantity", u.Quantity)
	populate(objectMap, "resourceId", u.ResourceID)
	populate(objectMap, "resourceUri", u.ResourceURI)
	populate(objectMap, "status", u.Status)
	populate(objectMap, "usageEventId", u.UsageEventID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UsageEventOkResponse.
func (u *UsageEventOkResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dimension":
				err = unpopulate(val, &u.Dimension)
				delete(rawMsg, key)
		case "effectiveStartTime":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				u.EffectiveStartTime = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "messageTime":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				u.MessageTime = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "planId":
				err = unpopulate(val, &u.PlanID)
				delete(rawMsg, key)
		case "quantity":
				err = unpopulate(val, &u.Quantity)
				delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, &u.ResourceID)
				delete(rawMsg, key)
		case "resourceUri":
				err = unpopulate(val, &u.ResourceURI)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, &u.Status)
				delete(rawMsg, key)
		case "usageEventId":
				err = unpopulate(val, &u.UsageEventID)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func populate_unused(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate_unused(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}



