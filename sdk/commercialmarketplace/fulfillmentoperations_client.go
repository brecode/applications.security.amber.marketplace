// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package commercialmarketplace

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
)

// FulfillmentOperationsClient contains the methods for the FulfillmentOperations group.
// Don't use this type directly, use NewFulfillmentOperationsClient() instead.
type FulfillmentOperationsClient struct {
	con *Connection
}

// NewFulfillmentOperationsClient creates a new instance of FulfillmentOperationsClient with the specified values.
func NewFulfillmentOperationsClient(con *Connection) *FulfillmentOperationsClient {
	return &FulfillmentOperationsClient{con: con}
}

// ActivateSubscription - Use this call to activate a subscription.
// If the operation fails it returns a generic error.
func (client *FulfillmentOperationsClient) ActivateSubscription(ctx context.Context, subscriptionID string, body SubscriberPlan, options *FulfillmentOperationsActivateSubscriptionOptions) (FulfillmentOperationsActivateSubscriptionResponse, error) {
	req, err := client.activateSubscriptionCreateRequest(ctx, subscriptionID, body, options)
	if err != nil {
		return FulfillmentOperationsActivateSubscriptionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FulfillmentOperationsActivateSubscriptionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FulfillmentOperationsActivateSubscriptionResponse{}, client.activateSubscriptionHandleError(resp)
	}
	return FulfillmentOperationsActivateSubscriptionResponse{RawResponse: resp.Response}, nil
}

// activateSubscriptionCreateRequest creates the ActivateSubscription request.
func (client *FulfillmentOperationsClient) activateSubscriptionCreateRequest(ctx context.Context, subscriptionID string, body SubscriberPlan, options *FulfillmentOperationsActivateSubscriptionOptions) (*azcore.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}/activate"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Header.Set("x-ms-requestid", *options.RequestID)
	}
	if options != nil && options.CorrelationID != nil {
		req.Header.Set("x-ms-correlationid", *options.CorrelationID)
	}
	return req, req.MarshalAsJSON(body)
}

// activateSubscriptionHandleError handles the ActivateSubscription error response.
func (client *FulfillmentOperationsClient) activateSubscriptionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		if len(body) == 0 {
      return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
    }
    return azcore.NewResponseError(errors.New(string(body)), resp.Response)
    }

// DeleteSubscription - Unsubscribe and delete the specified subscription.
// If the operation fails it returns a generic error.
func (client *FulfillmentOperationsClient) DeleteSubscription(ctx context.Context, subscriptionID string, options *FulfillmentOperationsDeleteSubscriptionOptions) (FulfillmentOperationsDeleteSubscriptionResponse, error) {
	req, err := client.deleteSubscriptionCreateRequest(ctx, subscriptionID, options)
	if err != nil {
		return FulfillmentOperationsDeleteSubscriptionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FulfillmentOperationsDeleteSubscriptionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return FulfillmentOperationsDeleteSubscriptionResponse{}, client.deleteSubscriptionHandleError(resp)
	}
	return client.deleteSubscriptionHandleResponse(resp)
}

// deleteSubscriptionCreateRequest creates the DeleteSubscription request.
func (client *FulfillmentOperationsClient) deleteSubscriptionCreateRequest(ctx context.Context, subscriptionID string, options *FulfillmentOperationsDeleteSubscriptionOptions) (*azcore.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Header.Set("x-ms-requestid", *options.RequestID)
	}
	if options != nil && options.CorrelationID != nil {
		req.Header.Set("x-ms-correlationid", *options.CorrelationID)
	}
	return req, nil
}

// deleteSubscriptionHandleResponse handles the DeleteSubscription response.
func (client *FulfillmentOperationsClient) deleteSubscriptionHandleResponse(resp *azcore.Response) (FulfillmentOperationsDeleteSubscriptionResponse, error) {
	result := FulfillmentOperationsDeleteSubscriptionResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Operation-Location"); val != "" {
		result.OperationLocationURI = &val
	}
	return result, nil
}

// deleteSubscriptionHandleError handles the DeleteSubscription error response.
func (client *FulfillmentOperationsClient) deleteSubscriptionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		if len(body) == 0 {
      return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
    }
    return azcore.NewResponseError(errors.New(string(body)), resp.Response)
    }

// GetSubscription - Gets the specified SaaS subscription. Use this call to get license information and plan information.
// If the operation fails it returns a generic error.
func (client *FulfillmentOperationsClient) GetSubscription(ctx context.Context, subscriptionID string, options *FulfillmentOperationsGetSubscriptionOptions) (FulfillmentOperationsGetSubscriptionResponse, error) {
	req, err := client.getSubscriptionCreateRequest(ctx, subscriptionID, options)
	if err != nil {
		return FulfillmentOperationsGetSubscriptionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FulfillmentOperationsGetSubscriptionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FulfillmentOperationsGetSubscriptionResponse{}, client.getSubscriptionHandleError(resp)
	}
	return client.getSubscriptionHandleResponse(resp)
}

// getSubscriptionCreateRequest creates the GetSubscription request.
func (client *FulfillmentOperationsClient) getSubscriptionCreateRequest(ctx context.Context, subscriptionID string, options *FulfillmentOperationsGetSubscriptionOptions) (*azcore.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Header.Set("x-ms-requestid", *options.RequestID)
	}
	if options != nil && options.CorrelationID != nil {
		req.Header.Set("x-ms-correlationid", *options.CorrelationID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSubscriptionHandleResponse handles the GetSubscription response.
func (client *FulfillmentOperationsClient) getSubscriptionHandleResponse(resp *azcore.Response) (FulfillmentOperationsGetSubscriptionResponse, error) {
	result := FulfillmentOperationsGetSubscriptionResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.Subscription); err != nil {
		return FulfillmentOperationsGetSubscriptionResponse{}, err
	}
	return result, nil
}

// getSubscriptionHandleError handles the GetSubscription error response.
func (client *FulfillmentOperationsClient) getSubscriptionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		if len(body) == 0 {
      return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
    }
    return azcore.NewResponseError(errors.New(string(body)), resp.Response)
    }

// ListAvailablePlans - Use this call to find out if there are any private or public offers for the current publisher.
// If the operation fails it returns a generic error.
func (client *FulfillmentOperationsClient) ListAvailablePlans(ctx context.Context, subscriptionID string, options *FulfillmentOperationsListAvailablePlansOptions) (FulfillmentOperationsListAvailablePlansResponse, error) {
	req, err := client.listAvailablePlansCreateRequest(ctx, subscriptionID, options)
	if err != nil {
		return FulfillmentOperationsListAvailablePlansResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FulfillmentOperationsListAvailablePlansResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FulfillmentOperationsListAvailablePlansResponse{}, client.listAvailablePlansHandleError(resp)
	}
	return client.listAvailablePlansHandleResponse(resp)
}

// listAvailablePlansCreateRequest creates the ListAvailablePlans request.
func (client *FulfillmentOperationsClient) listAvailablePlansCreateRequest(ctx context.Context, subscriptionID string, options *FulfillmentOperationsListAvailablePlansOptions) (*azcore.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}/listAvailablePlans"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Header.Set("x-ms-requestid", *options.RequestID)
	}
	if options != nil && options.CorrelationID != nil {
		req.Header.Set("x-ms-correlationid", *options.CorrelationID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listAvailablePlansHandleResponse handles the ListAvailablePlans response.
func (client *FulfillmentOperationsClient) listAvailablePlansHandleResponse(resp *azcore.Response) (FulfillmentOperationsListAvailablePlansResponse, error) {
	result := FulfillmentOperationsListAvailablePlansResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.SubscriptionPlans); err != nil {
		return FulfillmentOperationsListAvailablePlansResponse{}, err
	}
	return result, nil
}

// listAvailablePlansHandleError handles the ListAvailablePlans error response.
func (client *FulfillmentOperationsClient) listAvailablePlansHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		if len(body) == 0 {
      return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
    }
    return azcore.NewResponseError(errors.New(string(body)), resp.Response)
    }

// ListSubscriptions - Lists all the SaaS subscriptions for a publisher.
// If the operation fails it returns a generic error.
func (client *FulfillmentOperationsClient) ListSubscriptions(options *FulfillmentOperationsListSubscriptionsOptions) (*FulfillmentOperationsListSubscriptionsPager) {
	return &FulfillmentOperationsListSubscriptionsPager{
		client: client,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listSubscriptionsCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp FulfillmentOperationsListSubscriptionsResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SubscriptionsResponse.NextLink)
		},
	}
}

// listSubscriptionsCreateRequest creates the ListSubscriptions request.
func (client *FulfillmentOperationsClient) listSubscriptionsCreateRequest(ctx context.Context, options *FulfillmentOperationsListSubscriptionsOptions) (*azcore.Request, error) {
	urlPath := "/saas/subscriptions/"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	if options != nil && options.ContinuationToken != nil {
		reqQP.Set("continuationToken", *options.ContinuationToken)
	}
	req.URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Header.Set("x-ms-requestid", *options.RequestID)
	}
	if options != nil && options.CorrelationID != nil {
		req.Header.Set("x-ms-correlationid", *options.CorrelationID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listSubscriptionsHandleResponse handles the ListSubscriptions response.
func (client *FulfillmentOperationsClient) listSubscriptionsHandleResponse(resp *azcore.Response) (FulfillmentOperationsListSubscriptionsResponse, error) {
	result := FulfillmentOperationsListSubscriptionsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.SubscriptionsResponse); err != nil {
		return FulfillmentOperationsListSubscriptionsResponse{}, err
	}
	return result, nil
}

// listSubscriptionsHandleError handles the ListSubscriptions error response.
func (client *FulfillmentOperationsClient) listSubscriptionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		if len(body) == 0 {
      return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
    }
    return azcore.NewResponseError(errors.New(string(body)), resp.Response)
    }

// Resolve - The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource ID is the unique identifier
// for a SaaS subscription. When a user is redirected to a
// partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make a request to resolve it. The
// response contains the unique SaaS subscription ID,
// name, offer ID, and plan for the resource. This token is valid for one hour only.
// If the operation fails it returns a generic error.
func (client *FulfillmentOperationsClient) Resolve(ctx context.Context, xmsMarketplaceToken string, options *FulfillmentOperationsResolveOptions) (FulfillmentOperationsResolveResponse, error) {
	req, err := client.resolveCreateRequest(ctx, xmsMarketplaceToken, options)
	if err != nil {
		return FulfillmentOperationsResolveResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FulfillmentOperationsResolveResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FulfillmentOperationsResolveResponse{}, client.resolveHandleError(resp)
	}
	return client.resolveHandleResponse(resp)
}

// resolveCreateRequest creates the Resolve request.
func (client *FulfillmentOperationsClient) resolveCreateRequest(ctx context.Context, xmsMarketplaceToken string, options *FulfillmentOperationsResolveOptions) (*azcore.Request, error) {
	urlPath := "/saas/subscriptions/resolve"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Header.Set("x-ms-requestid", *options.RequestID)
	}
	if options != nil && options.CorrelationID != nil {
		req.Header.Set("x-ms-correlationid", *options.CorrelationID)
	}
	req.Header.Set("x-ms-marketplace-token", xmsMarketplaceToken)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// resolveHandleResponse handles the Resolve response.
func (client *FulfillmentOperationsClient) resolveHandleResponse(resp *azcore.Response) (FulfillmentOperationsResolveResponse, error) {
	result := FulfillmentOperationsResolveResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.ResolvedSubscription); err != nil {
		return FulfillmentOperationsResolveResponse{}, err
	}
	return result, nil
}

// resolveHandleError handles the Resolve error response.
func (client *FulfillmentOperationsClient) resolveHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		if len(body) == 0 {
      return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
    }
    return azcore.NewResponseError(errors.New(string(body)), resp.Response)
    }

// UpdateSubscription - Use this call to update the plan, the user count (quantity), or both.
// If the operation fails it returns a generic error.
func (client *FulfillmentOperationsClient) UpdateSubscription(ctx context.Context, subscriptionID string, body SubscriberPlan, options *FulfillmentOperationsUpdateSubscriptionOptions) (FulfillmentOperationsUpdateSubscriptionResponse, error) {
	req, err := client.updateSubscriptionCreateRequest(ctx, subscriptionID, body, options)
	if err != nil {
		return FulfillmentOperationsUpdateSubscriptionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FulfillmentOperationsUpdateSubscriptionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return FulfillmentOperationsUpdateSubscriptionResponse{}, client.updateSubscriptionHandleError(resp)
	}
	return client.updateSubscriptionHandleResponse(resp)
}

// updateSubscriptionCreateRequest creates the UpdateSubscription request.
func (client *FulfillmentOperationsClient) updateSubscriptionCreateRequest(ctx context.Context, subscriptionID string, body SubscriberPlan, options *FulfillmentOperationsUpdateSubscriptionOptions) (*azcore.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Header.Set("x-ms-requestid", *options.RequestID)
	}
	if options != nil && options.CorrelationID != nil {
		req.Header.Set("x-ms-correlationid", *options.CorrelationID)
	}
	return req, req.MarshalAsJSON(body)
}

// updateSubscriptionHandleResponse handles the UpdateSubscription response.
func (client *FulfillmentOperationsClient) updateSubscriptionHandleResponse(resp *azcore.Response) (FulfillmentOperationsUpdateSubscriptionResponse, error) {
	result := FulfillmentOperationsUpdateSubscriptionResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Operation-Location"); val != "" {
		result.OperationLocationURI = &val
	}
	return result, nil
}

// updateSubscriptionHandleError handles the UpdateSubscription error response.
func (client *FulfillmentOperationsClient) updateSubscriptionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		if len(body) == 0 {
      return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
    }
    return azcore.NewResponseError(errors.New(string(body)), resp.Response)
    }


