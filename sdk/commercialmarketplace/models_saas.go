// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package commercialmarketplace

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

type AADIdentifier struct {
	EmailID *string `json:"emailId,omitempty"`
	ObjectID *string `json:"objectId,omitempty"`
	Puid *string `json:"puid,omitempty"`
	TenantID *string `json:"tenantId,omitempty"`
}

type FulfillmentInternalServerErrorResponse struct {
	Error *FulfillmentInternalServerErrorResponseError `json:"error,omitempty"`
}

type FulfillmentInternalServerErrorResponseError struct {
	Code *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// FulfillmentOperationsActivateSubscriptionOptions contains the optional parameters for the FulfillmentOperations.ActivateSubscription method.
type FulfillmentOperationsActivateSubscriptionOptions struct {
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

// FulfillmentOperationsDeleteSubscriptionOptions contains the optional parameters for the FulfillmentOperations.DeleteSubscription method.
type FulfillmentOperationsDeleteSubscriptionOptions struct {
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

// FulfillmentOperationsGetSubscriptionOptions contains the optional parameters for the FulfillmentOperations.GetSubscription method.
type FulfillmentOperationsGetSubscriptionOptions struct {
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

// FulfillmentOperationsListAvailablePlansOptions contains the optional parameters for the FulfillmentOperations.ListAvailablePlans method.
type FulfillmentOperationsListAvailablePlansOptions struct {
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

// FulfillmentOperationsListSubscriptionsOptions contains the optional parameters for the FulfillmentOperations.ListSubscriptions method.
type FulfillmentOperationsListSubscriptionsOptions struct {
	// Optional value, only used for ListSubscriptions.
	ContinuationToken *string
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

// FulfillmentOperationsResolveOptions contains the optional parameters for the FulfillmentOperations.Resolve method.
type FulfillmentOperationsResolveOptions struct {
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

// FulfillmentOperationsUpdateSubscriptionOptions contains the optional parameters for the FulfillmentOperations.UpdateSubscription method.
type FulfillmentOperationsUpdateSubscriptionOptions struct {
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

type MeteringDimension struct {
	Currency *string `json:"currency,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`
	ID *string `json:"id,omitempty"`
	PricePerUnit *float32 `json:"pricePerUnit,omitempty"`
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty"`
}

type MeteringedQuantityIncluded struct {
	DimensionID *string `json:"dimensionId,omitempty"`
	Units *string `json:"units,omitempty"`
}

type Operation struct {
	Action *OperationActionEnum `json:"action,omitempty"`
	ActivityID *string `json:"activityId,omitempty"`
	ID *string `json:"id,omitempty"`
	OfferID *string `json:"offerId,omitempty"`
	PlanID *string `json:"planId,omitempty"`
	PublisherID *string `json:"publisherId,omitempty"`
	Quantity *int32 `json:"quantity,omitempty"`
	Status *OperationStatusEnum `json:"status,omitempty"`
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	TimeStamp *time.Time `json:"timeStamp,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", o.Action)
	populate(objectMap, "activityId", o.ActivityID)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "offerId", o.OfferID)
	populate(objectMap, "planId", o.PlanID)
	populate(objectMap, "publisherId", o.PublisherID)
	populate(objectMap, "quantity", o.Quantity)
	populate(objectMap, "status", o.Status)
	populate(objectMap, "subscriptionId", o.SubscriptionID)
	populate(objectMap, "timeStamp", (*timeRFC3339)(o.TimeStamp))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
				err = unpopulate(val, &o.Action)
				delete(rawMsg, key)
		case "activityId":
				err = unpopulate(val, &o.ActivityID)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &o.ID)
				delete(rawMsg, key)
		case "offerId":
				err = unpopulate(val, &o.OfferID)
				delete(rawMsg, key)
		case "planId":
				err = unpopulate(val, &o.PlanID)
				delete(rawMsg, key)
		case "publisherId":
				err = unpopulate(val, &o.PublisherID)
				delete(rawMsg, key)
		case "quantity":
				err = unpopulate(val, &o.Quantity)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, &o.Status)
				delete(rawMsg, key)
		case "subscriptionId":
				err = unpopulate(val, &o.SubscriptionID)
				delete(rawMsg, key)
		case "timeStamp":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				o.TimeStamp = (*time.Time)(&aux)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type OperationList struct {
	Operations []*Operation `json:"operations,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationList.
func (o OperationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "operations", o.Operations)
	return json.Marshal(objectMap)
}

type Plan struct {
	Description *string `json:"description,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`
	HasFreeTrials *bool `json:"hasFreeTrials,omitempty"`
	IsPricePerSeat *bool `json:"isPricePerSeat,omitempty"`
	IsPrivate *bool `json:"isPrivate,omitempty"`
	IsStopSell *bool `json:"isStopSell,omitempty"`
	Market *string `json:"market,omitempty"`
	PlanComponents *PlanComponents `json:"planComponents,omitempty"`
	PlanID *string `json:"planId,omitempty"`
}

type PlanComponents struct {
	MeteringDimensions []*MeteringDimension `json:"meteringDimensions,omitempty"`
	RecurrentBillingTerms []*RecurrentBillingTerm `json:"recurrentBillingTerms,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PlanComponents.
func (p PlanComponents) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "meteringDimensions", p.MeteringDimensions)
	populate(objectMap, "recurrentBillingTerms", p.RecurrentBillingTerms)
	return json.Marshal(objectMap)
}

type RecurrentBillingTerm struct {
	Currency *string `json:"currency,omitempty"`
	MeteredQuantityIncluded []*MeteringedQuantityIncluded `json:"meteredQuantityIncluded,omitempty"`
	Price *float32 `json:"price,omitempty"`
	TermDescription *string `json:"termDescription,omitempty"`
	TermUnit *TermUnitEnum `json:"termUnit,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RecurrentBillingTerm.
func (r RecurrentBillingTerm) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "currency", r.Currency)
	populate(objectMap, "meteredQuantityIncluded", r.MeteredQuantityIncluded)
	populate(objectMap, "price", r.Price)
	populate(objectMap, "termDescription", r.TermDescription)
	populate(objectMap, "termUnit", r.TermUnit)
	return json.Marshal(objectMap)
}

// ResolvedSubscription - Summary of the subscription
type ResolvedSubscription struct {
	ID *string `json:"id,omitempty"`
	OfferID *string `json:"offerId,omitempty"`
	PlanID *string `json:"planId,omitempty"`
	Quantity *int64 `json:"quantity,omitempty"`
	Subscription *Subscription `json:"subscription,omitempty"`
	SubscriptionName *string `json:"subscriptionName,omitempty"`
}

type SubscriberPlan struct {
	PlanID *string `json:"planId,omitempty"`
	Quantity *int64 `json:"quantity,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SubscriberPlan.
func (s SubscriberPlan) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "planId", s.PlanID)
	populate(objectMap, "quantity", s.Quantity)
	return json.Marshal(objectMap)
}

type Subscription struct {
	AllowedCustomerOperations []*AllowedCustomerOperationsEnum `json:"allowedCustomerOperations,omitempty"`

	// Indicating whether the subscription will renew automatically.
	AutoRenew *bool `json:"autoRenew,omitempty"`
	Beneficiary *AADIdentifier `json:"beneficiary,omitempty"`
	Created *time.Time `json:"created,omitempty"`
	FulfillmentID *string `json:"fulfillmentId,omitempty"`
	ID *string `json:"id,omitempty"`

	// true - the customer subscription is currently in free trial, false - the customer subscription is not currently in free trial.(optional field - default
// false)
	IsFreeTrial *bool `json:"isFreeTrial,omitempty"`

	// Indicating whether the current subscription is a test asset.
	IsTest *bool `json:"isTest,omitempty"`
	Name *string `json:"name,omitempty"`
	OfferID *string `json:"offerId,omitempty"`
	PlanID *string `json:"planId,omitempty"`
	PublisherID *string `json:"publisherId,omitempty"`
	Purchaser *AADIdentifier `json:"purchaser,omitempty"`
	Quantity *int32 `json:"quantity,omitempty"`

	// Indicates the status of the operation.
	SaasSubscriptionStatus *SubscriptionStatusEnum `json:"saasSubscriptionStatus,omitempty"`

	// Possible Values are None, Csp (Csp sandbox purchase)
	SandboxType *SandboxTypeEnum `json:"sandboxType,omitempty"`
	SessionID *string `json:"sessionId,omitempty"`

	// Dry Run indicates all transactions run as Test-Mode in the commerce stack
	SessionMode *SessionModeEnum `json:"sessionMode,omitempty"`
	StoreFront *string `json:"storeFront,omitempty"`
	Term *SubscriptionTerm `json:"term,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Subscription.
func (s Subscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allowedCustomerOperations", s.AllowedCustomerOperations)
	populate(objectMap, "autoRenew", s.AutoRenew)
	populate(objectMap, "beneficiary", s.Beneficiary)
	populate(objectMap, "created", (*timeRFC3339)(s.Created))
	populate(objectMap, "fulfillmentId", s.FulfillmentID)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "isFreeTrial", s.IsFreeTrial)
	populate(objectMap, "isTest", s.IsTest)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "offerId", s.OfferID)
	populate(objectMap, "planId", s.PlanID)
	populate(objectMap, "publisherId", s.PublisherID)
	populate(objectMap, "purchaser", s.Purchaser)
	populate(objectMap, "quantity", s.Quantity)
	populate(objectMap, "saasSubscriptionStatus", s.SaasSubscriptionStatus)
	populate(objectMap, "sandboxType", s.SandboxType)
	populate(objectMap, "sessionId", s.SessionID)
	populate(objectMap, "sessionMode", s.SessionMode)
	populate(objectMap, "storeFront", s.StoreFront)
	populate(objectMap, "term", s.Term)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Subscription.
func (s *Subscription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowedCustomerOperations":
				err = unpopulate(val, &s.AllowedCustomerOperations)
				delete(rawMsg, key)
		case "autoRenew":
				err = unpopulate(val, &s.AutoRenew)
				delete(rawMsg, key)
		case "beneficiary":
				err = unpopulate(val, &s.Beneficiary)
				delete(rawMsg, key)
		case "created":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				s.Created = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "fulfillmentId":
				err = unpopulate(val, &s.FulfillmentID)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &s.ID)
				delete(rawMsg, key)
		case "isFreeTrial":
				err = unpopulate(val, &s.IsFreeTrial)
				delete(rawMsg, key)
		case "isTest":
				err = unpopulate(val, &s.IsTest)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &s.Name)
				delete(rawMsg, key)
		case "offerId":
				err = unpopulate(val, &s.OfferID)
				delete(rawMsg, key)
		case "planId":
				err = unpopulate(val, &s.PlanID)
				delete(rawMsg, key)
		case "publisherId":
				err = unpopulate(val, &s.PublisherID)
				delete(rawMsg, key)
		case "purchaser":
				err = unpopulate(val, &s.Purchaser)
				delete(rawMsg, key)
		case "quantity":
				err = unpopulate(val, &s.Quantity)
				delete(rawMsg, key)
		case "saasSubscriptionStatus":
				err = unpopulate(val, &s.SaasSubscriptionStatus)
				delete(rawMsg, key)
		case "sandboxType":
				err = unpopulate(val, &s.SandboxType)
				delete(rawMsg, key)
		case "sessionId":
				err = unpopulate(val, &s.SessionID)
				delete(rawMsg, key)
		case "sessionMode":
				err = unpopulate(val, &s.SessionMode)
				delete(rawMsg, key)
		case "storeFront":
				err = unpopulate(val, &s.StoreFront)
				delete(rawMsg, key)
		case "term":
				err = unpopulate(val, &s.Term)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SubscriptionOperationsGetOperationStatusOptions contains the optional parameters for the SubscriptionOperations.GetOperationStatus method.
type SubscriptionOperationsGetOperationStatusOptions struct {
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

// SubscriptionOperationsListOperationsOptions contains the optional parameters for the SubscriptionOperations.ListOperations method.
type SubscriptionOperationsListOperationsOptions struct {
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

// SubscriptionOperationsUpdateOperationStatusOptions contains the optional parameters for the SubscriptionOperations.UpdateOperationStatus method.
type SubscriptionOperationsUpdateOperationStatusOptions struct {
	// A unique string value for operation on the client. This parameter correlates all events from client operation with events on the server side. If this
// value isn't provided, one will be generated and provided in the response headers.
	CorrelationID *string
	// A unique string value for tracking the request from the client, preferably a GUID. If this value isn't provided, one will be generated and provided in
// the response headers.
	RequestID *string
}

type SubscriptionPlans struct {
	Plans []*Plan `json:"plans,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SubscriptionPlans.
func (s SubscriptionPlans) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "plans", s.Plans)
	return json.Marshal(objectMap)
}

type SubscriptionTerm struct {
	EndDate *time.Time `json:"endDate,omitempty"`
	StartDate *time.Time `json:"startDate,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SubscriptionTerm.
func (s SubscriptionTerm) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "endDate", (*timeRFC3339)(s.EndDate))
	populate(objectMap, "startDate", (*timeRFC3339)(s.StartDate))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubscriptionTerm.
func (s *SubscriptionTerm) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endDate":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				s.EndDate = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "startDate":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				s.StartDate = (*time.Time)(&aux)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type SubscriptionsResponse struct {
	// Link to get the next set of subscriptions.
	NextLink *string `json:"@nextLink,omitempty"`
	Subscriptions []*Subscription `json:"subscriptions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SubscriptionsResponse.
func (s SubscriptionsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "@nextLink", s.NextLink)
	populate(objectMap, "subscriptions", s.Subscriptions)
	return json.Marshal(objectMap)
}

type UpdateOperation struct {
	PlanID *string `json:"planId,omitempty"`
	Quantity *int64 `json:"quantity,omitempty"`
	Status *UpdateOperationStatusEnum `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateOperation.
func (u UpdateOperation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "planId", u.PlanID)
	populate(objectMap, "quantity", u.Quantity)
	populate(objectMap, "status", u.Status)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}


